---
title: "2020 House Elections - Party Affiliation Analysis"
author: "Samuel Swank"
date: "March 13th, 2021"
output: html_notebook
---

# Background

|   This project grew out of [one which I had previously completed in Python](https://github.com/shengjiyang/2016-House-Results) examining how demographic factors were associated with party affiliation in the 2016 House Election. Due to time constraints, the demographic data used in the original project were limited to ethno-racial data. Thanks to the Census Bureau's [My Congressional District app](https://www.census.gov/mycd/) making the relevant data readily available by House district in *.csv* files, I was able to significantly expand the number of different demographic categories used in this project. For a full descriptive list of all the data used in this project see the data dictionary available in the [GitHub repository](https://github.com/shengjiyang/2020-House-Flipped-Seats). Thanks to the [CARES Act](https://home.treasury.gov/policy-issues/cares) providing grant money to local Universities to help individuals transition to more secure jobs, I had access, free of charge, to an *Intermediate R Coding* course where I learned to build a [corresponding shiny app](https://samuelswank.shinyapps.io/2020-House-Results/) to this *RPubs notebook*. For a full list of all the resources and packages used in the app's creation and in this notebook, see the README of the above-mentioned [GitHub repository](https://github.com/shengjiyang/2020-House-Flipped-Seats).

\  

## Research Question

|   The questions this project set out to answer are **what demographic factors were most strongly associated with a given district's party affiliation**, and **what characterized those districts which had sent a Democratic representative to congress in the previous election, but elected a Republican representative in the 2020 election**. This project was originally intended to include predictive models to address both these questions, but due to statistical issues with the latter, this analysis had been performed in a non-predictive manner in this notebook.

\  

|   The answer to the first question is fairly straightforward: those demographics associated with the metropolitan, urban centers, tend to be characteristic of House districts that elected Democratic candidates; whereas, those demographics associated with suburban and rural America, tend to be characteristic of those districts that chose Republican representatives.

# Model

## Methodology

### Preprocessing

|   The Census Bureau's estimates from the *2019 American Community Survey* were taken, and wherein it was reasonable to do so, these estimates were converted from their raw values to percentages of the estimated population of the district. For the sake of simplicity, the *margin of error* was not taken into account. These data were then standardized to account for those statistics, such as *median rent*, *median household income*, *etc.*, for which no percentage was taken.

\  

### Model Selection and Performance Metrics

|   I had initially wanted to replicate [the previous project's use of Logistic Regression](https://medium.com/swlh/democrat-or-republican-politics-and-logistic-regression-7639648be5f0) due to the method's simplicity and ease of interpretation for binary classification problems such as this one, but I later found R's implementations of the algorithm to be less friendly than Python's, so a *Random Forest* model was used instead. The `randomForest` package was used with all of the `randomForest` method's default parameters. Given that this was a classification problem, the relevant parameters were as follows: 

- `ntree = 500` 
- `replace = TRUE` 
- `nodesize = 1`
- `maxnodes = NULL`

|   Essentially the forest was composed of a healthy number of 500 trees with replacement sampling and no additional regularization for minimum node size or the maximum number of nodes used in a given tree. The model performance metrics were as follows.

```{r include=FALSE}
# Used
# randomForest
# yardstick

# tidyverse

# - tidyr
# - dplyr

# ggrepel

# knitr

# Attached
# graph
# igraph

library(knitr)
source("helpers/model/modelInfo.R")
```

```{r}
summary(testCM) %>% select(.metric, .estimate) %>% filter(
  .metric == "accuracy" |
  .metric == "bal_accuracy" |
  .metric == "mcc" |
  .metric == "precision" |
  .metric == "recall" | 
  .metric == "f_meas"
)
```

|   Considering that this is a fairly balanced classification problem with Democrats controlling `r sprintf("%.2f", (nrow(df %>% filter(party == "D")) / nrow(df)) * 100)`% of all House seats, and Republicans `r sprintf("%.2f", (nrow(df %>% filter(party == "R")) / nrow(df)) * 100)`%, *accuracy* by itself is a sufficient measure of model performance, beating a **baseline** prediction of `r sprintf("%.4f", (nrow(df %>% filter(party == "D")) / nrow(df)))`, wherein all districts where assumed to vote Democrat, by `r sprintf("%.4f", (summary(testCM) %>% filter(.metric == "precision") %>% pull(.estimate)) - (nrow(df %>% filter(party == "D")) / nrow(df)))`. For the sake of thoroughness, however, taking Republican as our positive case, as the model does, a *precision* of `r sprintf("%.4f", summary(testCM) %>% filter(.metric == "precision") %>% pull(.estimate))` indicates that model does a more than adequate job of not selecting true positives while keeping the false positive count fairly low. A lower *recall* of `r sprintf("%.4f", summary(testCM) %>% filter(.metric == "recall") %>% pull(.estimate))` indicates that there are still a moderate number of Republican districts which have been miss-classified as Democratic districts, an obvious weakness which will be examined herein. Overall, an *F-score* of `r sprintf("%.4f", summary(testCM) %>% filter(.metric == "f_meas") %>% pull(.estimate))` and a [*Matthew's Correlation Coefficient (MCC)*](https://towardsdatascience.com/the-best-classification-metric-youve-never-heard-of-the-matthews-correlation-coefficient-3bf50a2f3e9a) of `r sprintf("%.4f", summary(testCM) %>% filter(.metric == "mcc") %>% pull(.estimate))` indicate sufficient model performance for real-world relationships to be gleaned from the data. It should be noted that the *MCC* is measured on a scale from -1 to +1, so a score of `r sprintf("%.4f", summary(testCM) %>% filter(.metric == "mcc") %>% pull(.estimate))` is by no means poor.

\  

### Statistical Insights

|   Examining the *mean decrease in Gini impurity*, a measure which indicates the degree to which a given variable plays a role in classifying the data, we find that the following ten variables contributed the most to the model's final prediction.

```{r include = FALSE}
top.ten <- topTen
colnames(top.ten)[1] <- "Mean Decrease in Gini Impurity"
```

```{r}
top.ten
```

|   Though the *mean decrease in Gini impurity* tells us the importance of a given variable in the model's classification of a district as either Democrat or Republican, it does not tell us what relationship these variables have to the target variable. Looking at individual trees from the forest may give us a clue. Due to the sheer number of trees in our Random Forest model, however, it cannot be assumed that any given tree would perform well enough as a predictor to represent the Forest as a whole. At this stage, a graphical approach looking at individual, randomly-selected, representative voting districts seems to be the most intuitive approach.

\  

|   Given the demographics with the highest *mean decrease in Gini impurity*, the graphs below will represent the following categories:

- Race
- Place of Birth
- Commuter Method
- Residential Occupancy
- Rental Data

\  

|   In order to display this information, we will need to use our model's data prior to standardization, coupled with appropriate helper functions to aid in extracting the appropriate data.

```{r include=FALSE}
modelData <- read_csv("data/census/demographics/preprocessed/modelData.csv")

colnames(modelData)[1] <- "district"
modelData <- as.data.frame(modelData)
rownames(modelData) <- modelData$district
modelData <- modelData[, 2:(ncol(modelData) - 1)]

modelData[272, "party"] <- "R"
```

```{r}
modelData
```

```{r}
# '%!in%' <- Not In Operator
'%!in%' <- function(x,y){!('%in%'(x,y))}

# chartData <- function for extracting appropriate data from modelData data.frame
#              and converting from percentage to integers for use in graphs shown
#              below

chartData <- function(
  selectedDistrict, categories, grouping = NULL, n_seed = NULL
  ) {
  
  c <- c()
  for (i in 1:length(categories)) {
    c[i] <- (modelData[selectedDistrict, ] %>%
               select(categories) %>%
               .[[categories[i]]]) / 100
  }
  
  if (is.null(n_seed) == TRUE) {set.seed(n_seed)}
  
  # 710767 -> average_district_population
  sampleVec <- sample(categories, 710767, replace = TRUE, prob = c)
  counts <- table(sampleVec) %>% as.data.frame()
  
  # Accounting for groupings in bar chart
  if (is.null(grouping) == FALSE) {
    counts$group <- grouping
  }
  
  return(as.data.frame(counts))
}

# getRent <- function for extracting med_rent from modelData for use in density
#            plot

getRent <- function(selectedDistrict) {
  
  med_rent <- modelData[selectedDistrict, ] %>% pull(med_rent)
  
  return(as.character(med_rent))
}
```

**Democrat and Republican district subsets** for use in randomly selecting districts from each party.

```{r}
democrat   <- modelData %>% filter(party == "D")
republican <- modelData %>% filter(party == "R")

sprintf("(D: %d, R: %d)", nrow(democrat), nrow(republican))
```

```{r}
set.seed(50)  

d1 <- rownames(democrat) %>% sample(1) 
r1 <- rownames(republican) %>% sample(1)

sprintf("Democrat:   %s", d1)
sprintf("Republican: %s", r1)
```

#### **Race**
```{r include=FALSE}
racesd1 <- c(
  paste(
    "American Indians",
    paste(round(modelData[d1, "amerindian"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Asians", paste(round(modelData[d1, "asian"], 2), "%", sep = ""), sep = ": "
    ),
  paste(
    "Blacks", paste(round(modelData[d1, "black"], 2), "%", sep = ""), sep = ": "
    ),
  paste(
    "Pacific Islanders",
    paste(round(modelData[d1, "islander"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Multiracial Persons",
    paste(round(modelData[d1, "multiracial"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Persons of Other Races",
    paste(round(modelData[d1, "other_race"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Whites", paste(round(modelData[d1, "white"], 2), "%", sep = ""), sep = ": "
    )
  )
```

```{r}
ggplot(
  data = chartData(d1, colnames(modelData)[6:12], n_seed = 435),
  aes(x = "", y = Freq, fill = sampleVec)
  ) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  theme_minimal() +
  ggtitle(d1) +
  scale_fill_discrete(name = "", labels = racesd1) +
  theme(
    plot.title = element_text(
      size = 24, hjust = 0.5, family = "NewCenturySchoolbook"
      ),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )
```

```{r include=FALSE}
racesr1 <- c(
  paste(
    "American Indians",
    paste(round(modelData[r1, "amerindian"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Asians", paste(round(modelData[r1, "asian"], 2), "%", sep = ""), sep = ": "
    ),
  paste(
    "Blacks", paste(round(modelData[r1, "black"], 2), "%", sep = ""), sep = ": "
    ),
  paste(
    "Pacific Islanders",
    paste(round(modelData[r1, "islander"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Multiracial Persons",
    paste(round(modelData[r1, "multiracial"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Persons of Other Races",
    paste(round(modelData[r1, "other_race"], 2), "%", sep = ""),
    sep = ": "
    ),
  paste(
    "Whites", paste(round(modelData[r1, "white"], 2), "%", sep = ""), sep = ": "
    )
  )
```

```{r}
ggplot(
  data = chartData(r1, colnames(modelData)[6:12], n_seed = 435),
  aes(x = "", y = Freq, fill = sampleVec)
  ) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  theme_minimal() +
  ggtitle(r1) +
  scale_fill_discrete(name = "", labels = racesr1) +
  theme(
    plot.title = element_text(
      size = 24, hjust = 0.5, family = "NewCenturySchoolbook"
      ),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )
```

|   From the two districts sampled above **`r sprintf("%s District %s", strsplit(d1, split = " ")[[1]][1], strsplit(d1, split = " ")[[1]][2])`** and **`r sprintf("%s District %s", strsplit(r1, split = " ")[[1]][1], strsplit(r1, split = " ")[[1]][2])`**, we can see clearly that the former, a Democratic district has a greater degree of racial diversity compared with the latter. In the former *whites* make up only `r strsplit(racesd1[length(racesd1)], split = " ")[[1]][2]` of the population compared with the latter's `r strsplit(racesr1[length(racesr1)], split = " ")[[1]][2]`, a `r abs(modelData[d1, "white"] - modelData[r1, "white"]) %>% round(2)`% difference. *Asians* also make up around `r round(modelData[d1, "asian"] / modelData[r1, "asian"], 0)` times the percentage of total population in the `r strsplit(d1, split = " ")[[1]][1]` district, compared to that of the `r strsplit(r1, split = " ")[[1]][1]` district. The percentage of *persons of other races* is also higher in the Democratic district compared with that of the Republican. As noted in an [article](https://medium.com/swlh/democrat-or-republican-politics-and-logistic-regression-7639648be5f0) sharing the findings of the original project, this relationship between race and party affiliation should be viewed of as one of correlation rather than causation. Whites don't vote Republican regardless of where they live as the causational interpretation may suggest; rather, those who live in more rural, less racially diverse parts of the country do. As my reader will see below, race along with the other *high importance* factors stated above are simply surrogates for population density.

\  

#### **Place of Birth**
```{r}
set.seed(13)  

d2 <- rownames(democrat) %>% sample(1) 
r2 <- rownames(republican) %>% sample(1)

sprintf("Democrat:   %s", d2)
sprintf("Republican: %s", r2)
```

```{r}
birthplaceGrouping <- c(
  "Natural-born", "Natural-born", "Natural-born", "Naturalized", "Natural-born"
  )

birthplaceLabels <- c(
  "Born Abroad or in US Territory",
  "Born in State",
  "Born Out of State",
  "Foreign-born",
  "Natural Born"
  )
```


```{r}
d2Data <- chartData(d2, colnames(modelData)[18:22], n_seed = 42)
d2Data$group <- birthplaceGrouping

ggplot(data = d2Data[1:4, ], aes(x = group, y = Freq)) +
        geom_bar(stat = "identity", position = "dodge", aes(fill = sampleVec)) +
        theme_minimal() +
        scale_fill_discrete(name = "", labels = birthplaceLabels) +
        scale_y_continuous(
          labels = comma_format(big.mark = ",", decimal.mark = ".")
        ) +
        ggtitle(d2) +
        theme(
          plot.title = element_text(
            size = 24, hjust = 0.5, family = "NewCenturySchoolbook"
            ),
          axis.title.x = element_blank(),
          axis.title.y = element_blank()
        )
```

```{r}
r2Data <- chartData(r2, colnames(modelData)[18:22], n_seed = 42)
r2Data$group <- birthplaceGrouping

ggplot(data = r2Data[1:4, ], aes(x = group, y = Freq)) +
        geom_bar(stat = "identity", position = "dodge", aes(fill = sampleVec)) +
        theme_minimal() +
        scale_fill_discrete(name = "", labels = birthplaceLabels) +
        scale_y_continuous(
          labels = comma_format(big.mark = ",", decimal.mark = ".")
        ) +
        ggtitle(r2) +
        theme(
          plot.title = element_text(
            size = 24, hjust = 0.5, family = "NewCenturySchoolbook"
            ),
          axis.title.x = element_blank(),
          axis.title.y = element_blank()
        )
```

```{r}
birthplaceRows <- c(
  "Natural Born Citizen",
  "Born in State",
  "Born Out of State",
  "Born Abroad or in US Territory",
  "Foreign-born Citizen"
  )

d2Percentages <- t(modelData[d2, 18:22])
rownames(d2Percentages) <- birthplaceRows

r2Percentages <- t(modelData[r2, 18:22])
rownames(r2Percentages) <- birthplaceRows

d2Percentages
```

```{r}
r2Percentages
```

```{r include=FALSE}
source("dataWrangling/ballotpediaScraper.R")
```

|   Continuing our analysis with two different sampled districts, **`r sprintf("%s District %s", strsplit(d2, split = " ")[[1]][1], strsplit(d2, split = " ")[[1]][2])`**, a Democratic district, and **`r sprintf("%s District %s", strsplit(r2, split = " ")[[1]][1], strsplit(r2, split = " ")[[1]][2])`**, a Republican district, we find that a higher ratio of Foreign-born Citizens to Natural-born Citizens seems to be indicative that a given voting district with vote Democrat. Given that the vast majority of Americans are born with citizenship rather than are born non-citizens and later naturalized. According to the Census Bureau's *American Community Survery*, in 2014, the total population of the United States was estimated at `r floor(totalPop / 1000000)` million people, with `r round((totalNatural / totalPop) * 100, 0)`% natural-born citizens, compared to only `r round((totalNaturalized / totalPop) * 100, 0)`% naturalized citizens, with the remaining `r 100 - round((totalNatural / totalPop) * 100, 0) - round((totalNaturalized / totalPop) * 100, 0)`% non-citizens.