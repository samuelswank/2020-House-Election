---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tidyverse)
library(randomForest)
library(rpart)
library(rpart.plot)
library(logistf)
```

```{r}
sessionInfo()
```

Omit from published notebook

```{r}
workingDir <- getwd()
workingDir <- workingDir %>% strsplit(split = "/")
workingDir <- workingDir[[1]][1:6]
workingDir <- paste(
  workingDir[1],
  workingDir[2],
  workingDir[3],
  workingDir[4],
  workingDir[5],
  workingDir[6],
  sep = "/"
  )

workingDir
```


```{r}
df <- read.csv(
  paste(
    workingDir, "data/census/demographics/preprocessed/modelData.csv", sep = "/"
    )
  )

str(df)
```

```{r}
df$party <- df$party %>% sapply(as.factor)
class(df$party)
```

```{r}
for (col in colnames(df)) {
    if (class(df[[col]]) == "integer") {
        df[[col]] <- sapply(df[[col]], as.numeric)
    } 
}

str(df)
```

```{r}
df <- df[, !names(df) %in% c("med_smoc_mort", "med_smoc_no_mort"), drop = F]
colnames(df)
```
```{r}
df[269, "flipped"] <- TRUE
```

```{r}
scale.many <- function(dat, column.nos) {
  nms <- names(dat)
  for(col in column.nos) {
    name <- paste(nms[col],".z", sep = "")
    dat[name] <- scale(dat[,col])
  }
  cat(paste("Scaled ", length(column.nos), " variable(s)\n"))
  dat
}
```


```{r}
to.be.scaled <- 2:(length(colnames(df)) - 2)
dfScaled <- df %>% mutate_at(to.be.scaled, ~(scale(.) %>% as.vector))

row.names(dfScaled) <- dfScaled$districtDemographics
paScaled <- dfScaled[
  , !names(dfScaled) %in% c("districtDemographics", "flipped"), drop = F
  ]

paScaled
```

```{r}
Democrat   <- length((paScaled %>% subset(party == "D"))$party)
Republican <- length((paScaled %>% subset(party == "R"))$party)

baseline <- (Democrat / (Democrat + Republican)) * 100

sprintf("Baseline Accuracy: %.2f percent", baseline)
```

```{r}
set.seed(42)
sample <- caTools::sample.split(paScaled$party, SplitRatio = 0.8)

trainPA <- subset(paScaled, sample == TRUE)
testPA  <- subset(paScaled, sample == FALSE)

print(glue::glue("({length(trainPA$party)}, {length(testPA$party)})"))
```
```{r}
head(trainPA)
```


```{r}
head(testPA)
```


The model that is used in the app

```{r}
set.seed(42)
pa.model <- randomForest(party ~ ., data = trainPA)
pa.model
```

```{r}
varImpPlot(pa.model, n.var = 20, main = "Party Affiliation Model")
```

```{r}
varImportances <- importance(pa.model)
topTen <- varImportances[varImportances > 4, ] %>% sort(decreasing = TRUE)

topTen
```

```{r}
pa.train.preds <- data.frame(
  predicted = pa.model$predicted, actual = trainPA$party
  )

train.pa.cm <- yardstick::conf_mat(
  pa.train.preds, truth = actual, estimate = predicted
  )

summary(train.pa.cm)
```

```{r}
pa.test.preds <- pa.model %>% predict(testPA %>% select(1:65))

pa.test.preds <- data.frame(
  predicted = pa.test.preds, actual = testPA$party
  )

test.pa.cm <- yardstick::conf_mat(
  pa.test.preds, truth = actual, estimate = predicted
  )

test.pa.cm
```

```{r}
summary(test.pa.cm)
```


```{r}
pa.preds <- bind_rows(pa.train.preds, pa.test.preds) %>%
  select(predicted, actual)

head(pa.preds)
```
Fitting a single decision tree to 

```{r}
paTree <- rpart(
  party ~ walking_public_transit + renter_occupied + foreign_born,
  method='class',
  data = trainPA
  )

printcp(paTree)
```

```{r}
rpart.plot(paTree)
```

```{r}
paTree2 <- rpart(
  party ~ owner_occupied + car + white,
  method='class',
  data = paScaled
  )

printcp(paTree2)
```

```{r}
rpart.plot(paTree2)
```
```{r}
paTree3 <- rpart(
  party ~ natural_born_citizen + asian + other_race + med_rent,
  method='class',
  data = paScaled
  )

printcp(paTree3)
```
```{r}
rpart.plot(paTree3)
```
```{r}
flippedScaled <- dfScaled[
  , !names(dfScaled) %in% c("districtDemographics"), drop = F
  ]

flipped    <- length((flippedScaled %>% subset(flipped == TRUE))$flipped)
notFlipped <- length((flippedScaled %>% subset(flipped == FALSE))$flipped)


sprintf("Flipped Seats:   %d ", flipped - 1)
sprintf("Unflipped Seats: %d", notFlipped + 1)
```
```{r}
set.seed(1492)
propSample <- sample(
  1:nrow(flippedScaled %>% subset(party == "D" & flipped == FALSE)), 86
  )

propFlipped <- rbind(
  flippedScaled %>% subset(party == "R" & flipped == TRUE),
  flippedScaled[propSample, ]
  )

propFlipped <- propFlipped[sample(nrow(propFlipped)), ]

rownames(propFlipped)
```
```{r}
propFlipped$flipped
```

```{r}
propFlipped <- propFlipped[, !names(propFlipped) %in% c("party"), drop = F]
colnames(propFlipped)
```


```{r}
trainProp <- propFlipped[1:80, ]
testProp  <- propFlipped[81:100, ]

print(glue::glue("({nrow(trainProp)}, {nrow(testProp)})"))
```

```{r}
trainProp$flipped <- as.character(trainProp$flipped)
testProp$flipped <- as.character(testProp$flipped)

trainProp$flipped <- factor(trainProp$flipped, levels = c("TRUE", "FALSE"))
testProp$flipped <- factor(testProp$flipped, levels = c("TRUE", "FALSE"))
```


```{r}
for (i in 1:25) {
  set.seed(1812)
  treeModel <- randomForest(flipped ~ ., data = trainProp, ntree = i)
  sprintf("%d\n-----------------------------------------------------\n", i)
  flipped.train.preds <- data.frame(
  predicted = treeModel$predicted, actual = trainProp$flipped
  )

train.flipped.cm <- yardstick::conf_mat(
  flipped.train.preds, truth = actual, estimate = predicted
  )

print(
  summary(train.flipped.cm) %>%
    subset(
      .metric == "accuracy" |
      .metric == "mcc" |
      .metric == "precision" |
      .metric == "recall" |
      .metric == "f_meas"
      )
  )
}
```

```{r}
set.seed(1812)
# ntree = 9
propModel <- randomForest(flipped ~ ., data = trainProp, ntree = 9)
propModel
```
```{r}
flipped.train.preds <- data.frame(
  predicted = propModel$predicted, actual = trainProp$flipped
  )

train.flipped.cm <- yardstick::conf_mat(
  flipped.train.preds, truth = actual, estimate = predicted
  )

summary(train.flipped.cm)
```


```{r}
varImportances <- importance(propModel)
topTen <- varImportances[varImportances > 0.575, ] %>% sort(decreasing = TRUE)

topTen
```
```{r}
flipped.test.preds <- propModel %>% predict(testProp %>% select(1:64))

flipped.test.preds <- data.frame(
  predicted = flipped.test.preds, actual = testProp$flipped
  )

test.flipped.cm <- yardstick::conf_mat(
  flipped.test.preds, truth = actual, estimate = predicted
  )

test.flipped.cm
```
```{r}
summary(test.flipped.cm)
```








